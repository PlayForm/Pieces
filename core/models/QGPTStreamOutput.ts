/* tslint:disable */
/* eslint-disable */
/**
 * Pieces Isomorphic OpenAPI
 * Endpoints for Assets, Formats, Users, Asset, Format, User.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: tsavo@pieces.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists } from "../runtime.ts";
import type { QGPTAgentRoutes } from "./QGPTAgentRoutes.tsx";
import {
	QGPTAgentRoutesFromJSON,
	QGPTAgentRoutesToJSON,
} from "./QGPTAgentRoutes.tsx";
import type { QGPTQuestionOutput } from "./QGPTQuestionOutput.tsx";
import {
	QGPTQuestionOutputFromJSON,
	QGPTQuestionOutputToJSON,
} from "./QGPTQuestionOutput.tsx";
import type { QGPTRelevanceOutput } from "./QGPTRelevanceOutput.tsx";
import {
	QGPTRelevanceOutputFromJSON,
	QGPTRelevanceOutputToJSON,
} from "./QGPTRelevanceOutput.tsx";
import type { QGPTStreamEnum } from "./QGPTStreamEnum.tsx";
import {
	QGPTStreamEnumFromJSON,
	QGPTStreamEnumToJSON,
} from "./QGPTStreamEnum.tsx";
import type { QGPTStreamedOutputExtractedMaterials } from "./QGPTStreamedOutputExtractedMaterials.tsx";
import {
	QGPTStreamedOutputExtractedMaterialsFromJSON,
	QGPTStreamedOutputExtractedMaterialsToJSON,
} from "./QGPTStreamedOutputExtractedMaterials.tsx";

/**
 * This is the out for the /qgpt/stream endpoint.
 *
 * 200: success
 * 401: invalid authentication/api key
 * 429: Rate limit/Quota exceeded
 * 500: server had an error
 * 503: the engine is currently overloaded
 * @export
 * @interface QGPTStreamOutput
 */
export interface QGPTStreamOutput {
	/**
	 * This is the id used to represent the stream of response. this will always be present. We will use the value passed inby the client, or we will generate one.
	 * @type {string}
	 * @memberof QGPTStreamOutput
	 */
	request?: string;
	/**
	 *
	 * @type {QGPTRelevanceOutput}
	 * @memberof QGPTStreamOutput
	 */
	relevance?: QGPTRelevanceOutput;
	/**
	 *
	 * @type {QGPTQuestionOutput}
	 * @memberof QGPTStreamOutput
	 */
	question?: QGPTQuestionOutput;
	/**
	 *
	 * @type {QGPTStreamEnum}
	 * @memberof QGPTStreamOutput
	 */
	status?: QGPTStreamEnum;
	/**
	 * This is the ID of a predefined persisted conversation, if this is not present we will create a new conversation for the input/output.(in the case of a question)
	 * @type {string}
	 * @memberof QGPTStreamOutput
	 */
	conversation: string;
	/**
	 * This will be provided
	 * @type {number}
	 * @memberof QGPTStreamOutput
	 */
	statusCode?: number | null;
	/**
	 * optional error message is the status code is NOT 200
	 * @type {string}
	 * @memberof QGPTStreamOutput
	 */
	errorMessage?: string;
	/**
	 *
	 * @type {QGPTAgentRoutes}
	 * @memberof QGPTStreamOutput
	 */
	agentRoutes?: QGPTAgentRoutes;
	/**
	 *
	 * @type {QGPTStreamedOutputExtractedMaterials}
	 * @memberof QGPTStreamOutput
	 */
	extracted?: QGPTStreamedOutputExtractedMaterials;
}

/**
 * Check if a given object implements the QGPTStreamOutput interface.
 */
export function instanceOfQGPTStreamOutput(value: object): boolean {
	let isInstance = true;
	isInstance = isInstance && "conversation" in value;

	return isInstance;
}

export function QGPTStreamOutputFromJSON(json: any): QGPTStreamOutput {
	return QGPTStreamOutputFromJSONTyped(json, false);
}

export function QGPTStreamOutputFromJSONTyped(
	json: any,
	_ignoreDiscriminator: boolean,
): QGPTStreamOutput {
	if (json === undefined || json === null) {
		return json;
	}
	return {
		request: exists(json, "request") ? json["request"] : undefined,
		relevance: exists(json, "relevance")
			? QGPTRelevanceOutputFromJSON(json["relevance"])
			: undefined,
		question: exists(json, "question")
			? QGPTQuestionOutputFromJSON(json["question"])
			: undefined,
		status: exists(json, "status")
			? QGPTStreamEnumFromJSON(json["status"])
			: undefined,
		conversation: json["conversation"],
		statusCode: exists(json, "statusCode") ? json["statusCode"] : undefined,
		errorMessage: exists(json, "errorMessage")
			? json["errorMessage"]
			: undefined,
		agentRoutes: exists(json, "agentRoutes")
			? QGPTAgentRoutesFromJSON(json["agentRoutes"])
			: undefined,
		extracted: exists(json, "extracted")
			? QGPTStreamedOutputExtractedMaterialsFromJSON(json["extracted"])
			: undefined,
	};
}

export function QGPTStreamOutputToJSON(value?: QGPTStreamOutput | null): any {
	if (value === undefined) {
		return undefined;
	}
	if (value === null) {
		return null;
	}
	return {
		request: value.request,
		relevance: QGPTRelevanceOutputToJSON(value.relevance),
		question: QGPTQuestionOutputToJSON(value.question),
		status: QGPTStreamEnumToJSON(value.status),
		conversation: value.conversation,
		statusCode: value.statusCode,
		errorMessage: value.errorMessage,
		agentRoutes: QGPTAgentRoutesToJSON(value.agentRoutes),
		extracted: QGPTStreamedOutputExtractedMaterialsToJSON(value.extracted),
	};
}
